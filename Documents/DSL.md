# Что такое DSL?

DSL - это язык для описания шаблонов PM. Стандартных методов поиска, таких как поиск слова в тексте или текста, который удовлетворяет регулярному выражению, не хватает для эффективного анализа кода.
Для выявления программных закладок должна быть возможность адаптировать шаблоны PM к бизнес-логике приложения. При помощи DSL можно создать шаблон, который позволит находить блоки кода, содержащие разные типы, выражения и прочее, но схожие логически.

## Правила создания шаблонов

Шаблон представляет собой фрагмент кода, в котором часть значений может быть заменена на служебные элементы. Поддерживаемые языки программирования: С#, Java, PHP, PL/SQL, T-SQL, JavaScript. Шаблон может быть создан как для одного, так и для нескольких языков.

### Служебные элементы

1. `...` или `#*` - произвольное количество любых аргументов;
2. `#` - любое выражение;
3. `<[patternValue]>`. Используется для поиска по одному из шести шаблонных значений (patternValue). Допускаются и комбинации значений, в этом случае они объединяются оператором `||`.

### Типы примитивных значений

* `ID`: Идентификатор (ограничения: содержит только буквы латинского алфавита, цифры, `_` и `$`, не должен начинаться с цифры);
* `String`: Строка (ограничения: должна быть заключена в двойные кавычки `"`, не допускаются одиночные символы обратного слеша и двойной кавычки `\` и `"`; `\"` и `\\` допускаются);
* `Var`: Фиксированная переменная (содержит только буквы латинского алфавита, цифры, `_` и `$`, не может начинаться с цифры, перед именем переменной должен стоять знак `@`);
* `Number`:
    * Целое, восьмеричное (начинается с `0`) или шестнадцатеричное число (начинается с `0X`);
    * Выражение вида: `number (operator number)*`, где `operator` - это `+`, `-`, `*`, `/`;
    * Диапазон:
		* `number1..number2` соответствует диапазону, в котором левая граница включается, а правая - нет
		* `..` - бесконечный диапазон
		* `number1..` - диапазон, ограниченный снизу включая границу
		* `..number2` - диапазон, ограниченный сверху исключая границу
* `Bool`: `bool`, либо `true`, либо `false`;
* `Null`: пустое значение `null`.

### Типы примитивных конструкций

* `expression` - любая из конструкций **1-16** ниже.
* `patternValue` - регулярное выражение, диапазон чисел, либо любое примитивное значение.
* `regexString` - регулярное выражение для строк (обособляется двойными кавычками '"').
* `regexID` - регулярное выражение для идентификаторов.

### Допустимые выражения в шаблоне

1. `expression (<[||]> expression)+` - перечисление, при сопоставлении с кодом каждое выражение сравнивается отдельно;
2. `expression(args)` - вызов функции;
3. `expression.Id` или `expression.<[regexID]>` - обращение к члену объекта (поле, метод);
4. `(expression.)?Id` или `(expression.)?<[regexID]>` - аналогично предыдущему, выражение с точкой может отсутствовать;
5. `Id expression = expression` или `<[regexID]> expression = expression` - объявление переменной;
6. `expression = expression` - присваивание;
7. `new Id(args)` или `new <[regexID]>(args)` - создание объекта; 
8. `value` - примитивной значение `ID`, `Sting`, `Number`, `Bool` или `Null`;
9. `<[patternValue (|| patternValue)*]>` - перечисление, при сопоставлении с кодом шаблонное значение сравнивается отдельно;
10. `<[(~)? patternValue (|| (~)? patternValue)*]>` - перечисление с отрицанием. Если перечисление указывается для синтаксической конструкции, то используется синтаксис `<[~]>` 
11. `<[regexVar: (~)? patternValue (|| (~)? patternValue)*]>` - после двоеточия перечисляются допустимые значения для фиксированной переменной, например, password (это означает, что переменная является идентификатором password) или `3..10` (это означает, что переменная является числом из диапазона `3..10`);
12. `expression + expression` - сложение (конкатенация для строк, сложение для чисел);
13. `expression - expression` - вычитание;
14. `expression * expression` - умножение;
15. `expression / expression` - деление;
16. `expression[expression]` - обращение по индексу или ключу;
17. `Comment: <[regexString]>` - поиск в комментариях;
18. `try catch { }` - try-блок с пустым обработчиком исключения.
19. `<{ expression }>` - данная конструкция предписывает, что `expression` может находиться на любой глубине AST.

### Аргументы

Список `arg (, arg)*`, где `arg` - это:
* `expression`;
* `<[args]>`, или `...`, или `#*` - произвольное количество любых аргументов.

## Особенности создания шаблонов для языков PHP, PL/SQL, T-SQL

1. В названиях переменных знак `$` должен быть опущен;
2. Т.к. в PHP имена функций, а в T-SQL и PL/SQL вообще идентификаторы регистронезависимы, то модификаторы `(?i)...(?-i)` для них можно не использовать.

## Временное решение

Допустимые конструкции:
```
statement1
statement2
...
statementN
```
Где `statement` - это:
1. `expression;` - выражение и точка с запятой;
2. `<[~]> expression;` - любая инструкция, не содержащая данное выражение;
3. `...` - произвольное количество любых инструкций (может быть опущено);
4. `if (expression) {statement1 ... statementN}` - условный оператор с одной ветвью.
Для того чтобы обозначить одну и ту же переменную в разных инструкциях, необходимо использовать конструкцию `<[@var]>`, где `<[@var]>` - это regexVar.

## Примеры

1. `(#.)?<[(?i)password(?-i)]> = <["\w*" || null]>`,
	* `#` - любое выражение, которое может и отсутствовать;
	* `<[(?i)password(?-i)]>` - Регулярное выражение ID;
	* `<["\w*" || null]>` - Регулярное выражение String или Регулярное выражение Null;
	* `<[(?i)password(?-i)]>` можно переписать как `<[(?i)password]>`, т.к., если модификатор действует до конца регулярного выражения, то выключающий модификатор можно опустить.
2. `Configure.<[(?i)^write$]>("debug", <[1..9]>)`
	* `<[(?i)^write$]>` - Регулярное выражение ID;
	* `("debug", <[1..9]>)` - аргументы функции;
	* `<[1..9]>` - диапазон целых чисел от 1 до 9.
	* Если шаблон создается только для PHP, то его можно переписать следующим образом: `Configure.write("debug", <[1..9]>)`.
3. `new AllowAllHostnameVerifier(...) <[||]> SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER` - ищем `new AllowAllHostnameVerifier` с любым количеством аргументов или `SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER`. Для оператора "шаблонное или" `<[||]>` также доступна и сокращенная версия: `<|>`.
4. `# = _GET["url"]` - в шаблоне переменная `$_GET` указана без знака `$`.
5. `<[@pwd:password]> = #.Text;` - фиксированная переменная является идентификатором password;
   `~<[@pwd]> = #`
   `#.Session[<[""]>] = <[@pwd]>;`
6. `<{ document.<[^(URL|referrer|cookie)$]> }>`. Пример кода, на котором этот шаблон сопоставится:
`document.getElementById('test').onclick=function(){ document.URL + "a" }`

Шаблоны, для которых работает временное решение:

### Insecure Cookie (C#)

```
HttpCookie <[@cookie]> = new HttpCookie(...);
... // может быть опущено
<[~]><[@cookie]>.Secure = True;
... // может быть опущено
Response.Cookies.Add(<[@cookie]>);
```

### Insecure Cookie (Java)

```
Cookie <[@cookie]> = new Cookie(...);
...
<[~]><[@cookie]>.setSecure(true);
...
#.addCookie(<[@cookie]>);
```



